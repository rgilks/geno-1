/* eslint-disable no-console */
const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

function shortSha(sha) {
  if (!sha || typeof sha !== "string") return null;
  const cleaned = sha.trim();
  if (!cleaned) return null;
  return cleaned.slice(0, 8);
}

function getVersionTag() {
  const envCandidates = [
    process.env.GIT_COMMIT,
    process.env.COMMIT,
    process.env.SOURCE_COMMIT,
    process.env.VERCEL_GIT_COMMIT_SHA,
    process.env.GITHUB_SHA,
    process.env.CF_PAGES_COMMIT_SHA,
  ];
  for (const candidate of envCandidates) {
    const s = shortSha(candidate);
    if (s) return s;
  }

  try {
    const sha = execSync("git rev-parse --short HEAD", {
      stdio: ["ignore", "pipe", "ignore"],
    })
      .toString()
      .trim();
    if (sha) return sha;
  } catch (_) {
    // ignore
  }

  // Final fallback: time-based tag, stable within the build
  return `dev-${Math.floor(Date.now() / 1000).toString(36)}`;
}

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

function writeEnvJs(targetPath, version) {
  const contents = `// Auto-generated by scripts/gen-env.js
export const version = "${version}";
export function now() {
  if (typeof performance !== "undefined" && typeof performance.now === "function") {
    return performance.now();
  }
  return Date.now();
}
export default { version, now };
`;
  fs.writeFileSync(targetPath, contents, "utf8");
}

function main() {
  const repoRoot = path.resolve(__dirname, "..");
  const pkgDir = path.join(repoRoot, "pkg");
  ensureDir(pkgDir);

  const version = getVersionTag();
  const target = path.join(pkgDir, "env.js");
  writeEnvJs(target, version);
  console.log(
    `[gen-env] wrote ${path.relative(repoRoot, target)} with version: ${version}`
  );
}

main();
